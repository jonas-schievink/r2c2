//! A higher-level builder interface to C code generation.
//!
//! Notes on C namespaces and item naming:
//! * structs and unions share a namespace
//! * Local variables shadow functions
//! * Rust and C use the same identifier syntax, so escaping is difficult
//! * Keep all global identifiers as-is (should work due to mangling) and rename
//!   colliding locals

pub mod function;
pub mod test;
pub mod types;

use self::function::FunctionBuilder;
use self::types::{AsType, FnSig, IncompleteTypeRef, Type, TypeRef};
use utils::WriteStr;

use hashbrown::hash_map::{HashMap, RawEntryMut};
use hashbrown::HashSet;
use toolshed::Arena;

use bitflags::_core::fmt::{Error, Formatter};
use rustc::ty::{Instance, SymbolName, TyCtxt};
use rustc_index::{newtype_index, vec::IndexVec};
use std::borrow::Cow;
use std::fmt;
use std::io::{self, Write};
use std::rc::Rc;
use syntax::symbol::{Symbol, SymbolStr};

/// A Rust/C function or type name.
pub struct Name<'a> {
    rust: Cow<'a, str>,
    mangled: Symbol,
}

impl<'a> Name<'a> {
    /// Create a `Symbol` for a monomorphized `Instance`.
    pub fn for_instance<'tcx>(inst: &Instance<'tcx>, tcx: TyCtxt<'tcx>) -> Self {
        Self {
            rust: inst.to_string().into(),
            mangled: tcx.symbol_name(*inst).name,
        }
    }

    /// A test symbol that doesn't have an associated Rust name (used only by unit tests).
    pub fn test(c_name: &'a str) -> Self {
        Self {
            rust: "(test-symbol: no associated Rust name)".into(),
            mangled: Symbol::intern(c_name),
        }
    }

    /// Returns the Rust path to the symbol (possibly containing a comment).
    pub fn rust(&self) -> &str {
        &self.rust
    }

    /// Returns the mangled C name of this symbol.
    pub fn mangled(&self) -> SymbolStr {
        self.mangled.as_str()
    }
}

/// A builder for C translation units.
///
/// A "translation unit" is a single `.c` file and corresponds directly to a
/// codegen unit in Rust.
pub struct TranslationUnitBuilder<'a, W: WriteStr> {
    /// Output file writer.
    writer: W,

    /// Arena storing TU-wide data (types, type names, etc.).
    arena: &'a Arena,

    /// `struct`s and `union`s that have been defined (not declared) so far.
    defd_types: HashSet<&'a str>,
}

impl<'a, W: WriteStr> TranslationUnitBuilder<'a, W> {
    /// Creates a new C file builder that writes its output to `writer`.
    ///
    /// This will also write the preamble to the writer, which includes standard
    /// files that are assumed to be present by the rest of the code generator.
    pub fn create(arena: &'a Arena, writer: W) -> io::Result<Self> {
        let mut this = Self {
            writer,
            arena,
            defd_types: HashSet::new(),
        };

        // Include a few standard headers the code generator relies on
        this.comment(&format!(
            "generated by r2c2 version {}",
            env!("CARGO_PKG_VERSION")
        ))?;
        this.include("stdint.h")?;
        this.include("stdbool.h")?;
        this.separator("END PREAMBLE")?;

        Ok(this)
    }

    /// Returns the output file writer associated with this TU builder.
    pub fn writer(&mut self) -> &mut W {
        &mut self.writer
    }

    pub fn into_writer(self) -> W {
        self.writer
    }

    fn include(&mut self, sys: &str) -> io::Result<()> {
        writeln!(self.writer, "#include <{}>", sys)
    }

    fn comment(&mut self, comment: &str) -> io::Result<()> {
        for line in comment.lines() {
            writeln!(self.writer, "/* {} */", line.replace("*/", "*-/"))?;
        }
        Ok(())
    }

    /// Emits 3 comment lines to separate different pieces of output.
    pub fn separator(&mut self, name: &str) -> io::Result<()> {
        writeln!(self.writer)?;
        self.comment(&" ".repeat(50))?;

        let spaces = 50usize.saturating_sub(name.len());
        let text = format!(
            "{}{}{}",
            " ".repeat(spaces / 2),
            name,
            " ".repeat((spaces + 1) / 2)
        );
        self.comment(&text)?;

        self.comment(&" ".repeat(50))?;
        writeln!(self.writer)?;
        Ok(())
    }
}

macro_rules! prim {
    ($fnname:ident $tname:ident) => {
        fn $fnname(&self) -> TypeRef<'a> {
            TypeRef(&Type::$tname)
        }
    };
}

impl<'a, W: WriteStr> TranslationUnitBuilder<'a, W> {
    prim!(bool Bool);
    prim!(u8 U8);
    prim!(i8 I8);
    prim!(u16 U16);
    prim!(i16 I16);
    prim!(u32 U32);
    prim!(i32 U32);
    prim!(u64 U64);
    prim!(i64 I64);
    prim!(float Float);
    prim!(double Double);
    prim!(intptr IntPtr);
    prim!(uintptr UintPtr);

    pub fn void(&self) -> IncompleteTypeRef<'a> {
        IncompleteTypeRef(&Type::Void)
    }

    /// Builds a pointer type pointing to `pointee`.
    pub fn ptr_to<Ty: AsType<'a>>(&mut self, pointee: Ty) -> TypeRef<'a> {
        TypeRef(self.arena.alloc(Type::Pointer(pointee.as_type())))
    }

    pub fn fn_sig(&mut self, ret: Option<TypeRef<'a>>, args: &[TypeRef<'a>]) -> FnSig<'a> {
        let ret = ret.unwrap_or(TypeRef(&Type::Void));
        FnSig {
            ret,
            args: self.arena.alloc_slice(args),
        }
    }

    pub fn fn_ptr(&mut self, sig: FnSig<'a>) -> TypeRef<'a> {
        TypeRef(self.arena.alloc(Type::FunctionPointer(sig)))
    }

    /// Emits a forward-declaration of a struct `inst`.
    pub fn fwd_declare_struct(&mut self, sym: Name<'_>) -> io::Result<IncompleteTypeRef<'a>> {
        writeln!(
            self.writer,
            "struct {};  /* {} */",
            sym.mangled(),
            sym.rust()
        )?;
        let name = self.arena.alloc_str(&sym.mangled());
        Ok(IncompleteTypeRef(
            self.arena.alloc(Type::FwdStruct { name }),
        ))
    }

    /// Emits a forward-declaration of a union `inst`.
    pub fn fwd_declare_union(&mut self, sym: Name<'_>) -> io::Result<IncompleteTypeRef<'a>> {
        writeln!(
            self.writer,
            "union {};  /* {} */",
            sym.mangled(),
            sym.rust()
        )?;
        let name = self.arena.alloc_str(&sym.mangled());
        Ok(IncompleteTypeRef(self.arena.alloc(Type::FwdUnion { name })))
    }

    pub fn fwd_declare_function(
        &mut self,
        name: Name<'_>,
        proto: FnSig<'a>,
    ) -> io::Result<Function<'a>> {
        proto.declare(&*name.mangled(), &mut self.writer)?;
        let fnty = self.fn_ptr(proto);
        writeln!(self.writer, "; /* {} */", name.rust())?;
        Ok(Function {
            sig: proto,
            ptr_ty: fnty,
            name: self.arena.alloc_str(&name.mangled()),
        })
    }

    fn define_named_type<'f, F>(
        &mut self,
        kind: &str,
        sym: Name<'_>,
        fields: F,
    ) -> io::Result<TypeRef<'a>>
    where
        F: IntoIterator<Item = (&'f str, TypeRef<'a>)>,
    {
        if self.defd_types.contains(&*sym.mangled()) {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                format!("type '{}' already defined", sym.mangled()),
            ));
        }

        writeln!(
            self.writer,
            "{} {} {{  /* {} */",
            kind,
            sym.mangled(),
            sym.rust()
        )?;
        for (field, ty) in fields {
            write!(self.writer, "    ")?;
            ty.declare_variable(field, &mut self.writer)?;
            writeln!(self.writer, ";")?;
        }
        writeln!(self.writer, "}};")?;

        let name = self.arena.alloc_str(&sym.mangled());
        self.defd_types.insert(name);
        Ok(TypeRef(self.arena.alloc(Type::Struct { name })))
    }

    /// Defines a `struct` with field names and types.
    // TODO attach attributes
    pub fn define_struct<'f, F>(&mut self, sym: Name<'_>, fields: F) -> io::Result<TypeRef<'a>>
    where
        F: IntoIterator<Item = (&'f str, TypeRef<'a>)>,
    {
        self.define_named_type("struct", sym, fields)
    }

    /// Defines a `union` with field names and types.
    pub fn define_union<'f, F>(&mut self, sym: Name<'_>, fields: F) -> io::Result<TypeRef<'a>>
    where
        F: IntoIterator<Item = (&'f str, TypeRef<'a>)>,
    {
        self.define_named_type("union", sym, fields)
    }

    /// Starts defining a function, returning a `FunctionBuilder`.
    pub fn define_function<'b>(
        &'b mut self,
        arena: &'b Arena,
        name: Name<'_>,
        proto: FnSig<'a>,
    ) -> io::Result<FunctionBuilder<'b, W>> {
        Ok(FunctionBuilder::create(
            &mut self.writer,
            arena,
            name,
            proto,
        )?)
    }
}

/// A declared function.
pub struct Function<'a> {
    sig: FnSig<'a>,
    ptr_ty: TypeRef<'a>,
    name: &'a str,
}

#[cfg(test)]
mod tests {
    use super::test::compile_test;
    use super::*;
    use utils::StringWriter;

    use cc::Build;
    use std::error::Error;
    use tempfile::{self, TempDir};

    #[test]
    fn fwd_declare() {
        compile_test("fwd_declare", |f| {
            let i = f.i32();
            let _p = f.ptr_to(i);
            let v = f.void();
            let _p = f.ptr_to(v);

            f.fwd_declare_struct(Name::test("my_struct"))?;
            f.fwd_declare_union(Name::test("my_union"))?;
            Ok(())
        });
    }

    #[test]
    #[should_panic(expected = "already defined")]
    fn redefinition() {
        // A test that's supposed to fail has to panic inside the closure, or
        // else `test` will compile the output.
        compile_test("redefinition", |f| {
            let bool = f.bool();
            f.define_struct(Name::test("my_struct"), vec![("field1", bool)])?;
            let msg = f
                .define_struct(Name::test("my_struct"), vec![("field2", bool)])
                .unwrap_err()
                .to_string();
            panic!("{}", msg);
        });
    }

    #[test]
    fn define_struct() {
        compile_test("define_struct", |f| {
            let i = f.i32();
            let pi = f.ptr_to(i);
            let v = f.void();
            let pv = f.ptr_to(v);
            let b = f.bool();

            f.fwd_declare_struct(Name::test("my_struct"))?;
            f.fwd_declare_union(Name::test("my_union"))?;

            f.define_struct(
                Name::test("my_struct"),
                vec![
                    ("intfield", i),
                    ("intptr", pi),
                    ("voidptr", pv),
                    ("shevik", b),
                ],
            )?;
            Ok(())
        });
    }

    /// Defines a struct containing function pointer fields.
    #[test]
    fn define_struct_fn_ptr() {
        compile_test("define_struct_fn_ptr", |f| {
            let i = f.i32();
            let pi = f.ptr_to(i);
            let v = f.void();
            let pv = f.ptr_to(v);
            let b = f.bool();
            let fn_sig = f.fn_sig(Some(pi), &[i, i, b]);
            let fn_ptr = f.fn_ptr(fn_sig);
            let fn_sig = f.fn_sig(None, &[i, i, b]);
            let fn_ptr2 = f.fn_ptr(fn_sig);
            let fn_sig = f.fn_sig(Some(i), &[]);
            let fn_ptr3 = f.fn_ptr(fn_sig);

            f.define_struct(
                Name::test("my_struct"),
                vec![("f1", fn_ptr), ("f2", fn_ptr2), ("f3", fn_ptr3)],
            )?;
            Ok(())
        });
    }

    #[test]
    fn fwd_declare_fn() {
        compile_test("fwd_declare_fn", |f| {
            let i = f.i32();
            let pi = f.ptr_to(i);
            let b = f.bool();

            let sig = f.fn_sig(Some(pi), &[i, i, b]);
            f.fwd_declare_function(Name::test("myfn"), sig)?;
            let sig = f.fn_sig(None, &[]);
            f.fwd_declare_function(Name::test("empty"), sig)?;
            Ok(())
        });
    }

    #[test]
    fn def_fn() {
        compile_test("def_fn", |f| {
            let i = f.i32();
            let pi = f.ptr_to(i);
            let b = f.bool();

            // TODO: Test more way to declare fns (returning fn ptr, nothing, taking no args, ...)
            let sig = f.fn_sig(Some(pi), &[i, i, b]);
            let arena = Arena::new();
            let b = f.define_function(&arena, Name::test("myfn"), sig)?;
            b.finish()?;
            Ok(())
        });
    }
}
